<html>
  <head>
    <title>FortWrap Examples</title>
    <link rel=stylesheet href="style.css" type="text/css">
  </head>
  
  <body>
    <h1>Examples</h1>

    <p>Note that for simplicity, some of the examples below are not
    shown with derived types.  When the first argument is not a
    derived type, FortWrap by default wraps the routine as a static
    method of the special "utility class" <tt>FortFuncs</tt> (this can
    be overriden with the <tt>--global</tt> option).</p>


    <h2>Derived Types</h2>

    <p>"<tt>ctor</tt>" procedures are wrapped as C++ constructors.
      Multiple constructors are supported.  "<tt>dtor</tt>" procedures
      are automatically called by the C++ destructor.  For
      example:</p>

 <div class="code"> <pre>
MODULE m

  TYPE Object
    REAL, ALLOCATABLE :: x(:)
  END TYPE Object

CONTAINS

  SUBROUTINE default_ctor(o,n)
    TYPE(Object) :: o
    INTEGER, INTENT(in) :: n
    ALLOCATE(o%x(n))
  END SUBROUTINE default_ctor

  SUBROUTINE value_ctor(o,n,val)
    TYPE(Object) :: o
    INTEGER, INTENT(in) :: n
    REAL, INTENT(in) :: val
    ALLOCATE(o%x(n))
    o%x = val
  END SUBROUTINE value_ctor

  SUBROUTINE object_dtor(o)
    TYPE(Object) :: o
    IF(ALLOCATED(o%x)) DEALLOCATE(o%x)
  END SUBROUTINE object_dtor

END MODULE m
  </pre></div>

    <p> will generate multiple constructors for the C++
    class <tt>Object</tt>:</p>

    <div class="targetlang"> <pre>
Object(int n);
Object(int n, float val);
    </pre></div>

    <p>The Fortran destructor <tt>object_dtor</tt> will automatically
    be called by the C++ destructor.</p>
    

    <h2>Arrays</h2>

  <div class="code"> <pre>
FUNCTION inner_prod(n,a,b) RESULT(y)
  INTEGER, INTENT(in) :: n, a(n), b(n)
  INTEGER :: y
  y = DOT_PRODUCT(a,b)
END FUNCTION inner_prod
  </pre></div>

    <p>generates a method of the "utility class" <tt>FortFuncs</tt>
    (the utility class is used to wrap functions that do not operate
    on a derived type):</p>

    <div class="targetlang"> <pre>
static int inner_prod(const std::vector<int>* a, const std::vector<int>* b);
    </pre></div>

    <h2>Optional Arguments</h2>

    <div class="code"> <pre>
FUNCTION add_mixed(a,b,c,d) RESULT(y)
  INTEGER, INTENT(in) :: a,b
  INTEGER, INTENT(in), OPTIONAL :: c,d
  INTEGER :: y
  y = a+b
  IF (PRESENT(c)) y = y + c
  IF (PRESENT(d)) y = y + d
END FUNCTION add_mixed
    </pre></div>

    <p>generates the following method:</p>

    <div class="targetlang"> <pre>
static int add_mixed(int a, int b, const int* c=NULL, const int* d=NULL);
    </pre></div>

    <p>Note that <tt>a</tt> and <tt>b</tt> use pass-by-value since
      they are not optional.  The optional arguments <tt>c</tt>
      and <tt>d</tt> use pass-by-reference.  Passing <tt>NULL</tt>
      (which is the default) indicates that the argument is not
      provided.</p>
    
    <p>These wrappers are particularly powerful when using swig
    with <tt>-c++ -keyword</tt>, since the optional parameters can
    then be passed by keyword in the target language</p>


  </body>
</html>
