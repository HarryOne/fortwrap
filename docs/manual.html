<html>
  <head>
    <title>FortWrap Manual</title>
    <link rel=stylesheet href="style.css" type="text/css">
  </head>
    
<body>
  <h1>FortWrap Manual</h1>

<ul>
  <li><a href="#Introduction">Introduction</a></li>
  <li><a href="#Features">Main Features</a></li>
  <li><a href="#Unsupported">Unsupported Features</a></li>
  <li><a href="#GetStarted">Getting Started</a></li>
  <li><a href="#ConfigFile">The Configuration File</a></li>
  <li><a href="#Swig">Swig Tips (or "How to use with other languages")</a></li>
  <li><a href="#Details">Wrapper Details</a></li>
  <li><a href="#Files">Generated Files</a></li>
  <li><a href="#Support">Support</a></li>
</ul>

  <h2><a name="Introduction">Introduction</a></h2>

  <p>FortWrap is a Python script that parses Fortran 90/95/200X source
  files and generates wrapper code for interfacing with the original
  Fortran code from C++.  FortWrap is intended to be used with Fortran
  code that takes an object oriented approach and makes use of Fortran
  derived types.  The resulting wrapper code provides a C++ interface
  that wraps the Fortran derived types with C++ proxy classes.</p>

  <p>For example, consider the following Fortran code:</p>

  <div class="code"> <pre>
MODULE m

  TYPE Object
    ... 
  END TYPE Object

CONTAINS
    
  SUBROUTINE object_ctor(o, n, x)
    TYPE (Object) :: o
    INTEGER, INTENT(in) :: n
    REAL, INTENT(in) :: x(n)
    ...
  END SUBROUTINE object_ctor

  SUBROUTINE process(o)
    TYPE (Object) :: o
    ...
  END SUBROUTINE process
  
END MODULE m
  </pre></div>      

  <p>After wrapping with FortWrap, these routines can be utilized in a
  natural way from C++:</p>

  <div class="targetlang"> <pre>
std::vector&lt;float&gt; x(10);
... // Define values for x
Object o(&x); // Automatically calls object_ctor
o.process();
  </pre></div>

  <h2><a name="Features">Main Features</a></h2>

<ul>
  <li> <a href="#details-dt"><b>Derived Types</b></a>: Transparent
  translation of Fortran derived types into C++ classes.  This is the
  main objective of FortWrap.</li>
  <ul>
    <li> Translation of Fortran "ctor" functions into C++ constructors</li>
    <li> Fortran "dtor" functions automatically called by C++ destructor</li>
  </ul>

  <li> <a href="#details-opt"><b>Optional arguments</b></a>: Fortran
    optional arguments are fully supported, with automatic NULL
    default values in C++.</li>

  <li> <a href="#details-procpointers"><b>Procedure pointers</b></a>:
    C++ function pointers may be passed natively where Fortran expects
    a procedure pointer.  Right now this requires that the Fortran
    procedure pointer have an explicit <tt>ABSTRACT
    INTERFACE</tt></li>
  
  <li> <a href="#details-arrays"><b>Arrays</b></a>: By default,
    one-dimensional arrays are translated into C++ vector containers.
    Subroutine arguments used to define the Fortran array size are
    automatically calculated based on the C++ vector.</li>
  
  <li> <a href="#details-matrices"><b>Matrices</b></a>: A
    "FortranMatrix" C++ class is provided for interfacing with
    two-dimensional Fortran arrays (matrices).  This class takes care
    to store data internally in Fortran order.</li>

  <li> Name mangling support for both gfortran and g95 compilers
    
  <li> <a href="#details-strings">Character arrays</a>
    with <tt>INTENT(OUT)</tt> and explicit length parameter are
    translated into C++ strings.</li>

  <li> Where possible, pass by value is used in C++ (e.g. scalar
    arguments that are not optional)</li>

  <li> <b>Doxygen comments</b>: Doxygen-style comments used for
    Fortran symbols (derived types, subroutines, arguments) are
    transferred to C++ doxygen comments in the wrapper code.</li>

  <li> Automatic handling of Fortran <tt>PUBLIC</tt>
    and <tt>PRIVATE</tt> statements.  By default, only <tt>PUBLIC</tt>
    routines are wrapped.</li>
</ul>

<h2><a name="Unsupported">Unsupported Features</a></h2>

<p>Many features of Fortran 90/95/2003 are not supported by FortWrap.  In
some cases (e.g. assumed shape arrays) this is because the Fortran
language standard does not provide an interoperability mechanism.  In
other cases, this is because there was not a need for certain features
  when the original version of FortWrap was being developed.</p>

<p>In most situations, it is possible to get FortWrap to wrap these
types of routines by providing a Fortran wrapper that is interoperable
and calls the target routine.</p>

<p>The following argument types/constructs/features are not
supported:</p>

<ul>
  <li>"Top-level" (a.k.a. global or non-module) procedures are not
    currently wrapped.  Note that FortWrap is geared towards wrapping
    modern Fortran code, not legacy code.</li>

  <li><tt>ALLOCATABLE</tt> or <tt>POINTER</tt> arguments</li>

  <li> Assumed shape arrays (a declaration that looks like <tt>INTEGER
      :: X(:)</tt>).  The Fortran standard does not provide an
      interoperability mechanism for assumed shape arrays.</li>

  <li> Assumed size arrays (<tt>INTEGER :: X(*)</tt>).  These could be
    supported but are less useful than providing an explicit size
    because the Fortran routine will not know the size of the
    array.</li>

  <li> Character arrays with intent other than <tt>INTENT(OUT)</tt></li>

  <li> Arrays of dimensionality greater than 2 are not supported.</li>

  <li> <tt>KIND</tt>: only limited support is provided for specifying
    the <tt>KIND</tt> of primitive types.  For <tt>REAL</tt>
    arguments, <tt>KIND</tt>s of 4 and 8 are supported
    (<tt>REAL*8</tt> is also recognized), otherwise <tt>KIND</tt> is
    not supported.</li>

  <li> Arrays of a derived type.  These can be wrapped by creating a
    new derived type to contain an array of the derived type of
    interest.  Create an "append" function in Fortran that accepts
    only scalars but allows you to add items to the array container
    one at a time.</li>

  <li> Fortran functions with non-primitive return types are not
    wrapped.</li>

  <li> <b>CLASS</b> (polymorphic) variables.  This Fortran language
    features is not supported by g95 and is currently making its way
    online with gfortran.  Unfortunately, the Fortran 2003 standard
    does not allow C_LOC to be used on <tt>CLASS</tt> pointers, so
    there is not a standard-compliant way of working with these
    variables.  However, experimental support for FortWrap to generate
    polymorphic C++ wrappers around Fortran <tt>CLASS</tt> constructs
    is already underway, although it relies on gfortran-specific
    compiler implementation details and a patched version of the
    compiler.</li>

  <li>Type bound procedures.  Those that were not declared
    as <tt>NOPASS</tt> require that the first argument be declared
    using <tt>CLASS</tt> instead of <tt>TYPE</tt>.  FortWrap does not
    currently handle <tt>CLASS</tt>: see above.</li>
</ul>

  <p>Note that FortWrap can still wrap procedures that use unsupported
    arguments if those arguments are optional.  In these cases, the
    offending arguments are hidden from the generated interface
    code.</p>



<h2><a name="GetStarted">Getting Started</a></h2>

<ul>
  <li>See <tt>README.txt</tt></li>
  <li>Run "<tt>fortwrap.py -h</tt>" for usage information</li>
  <li>Look in the tests directory at examples</li>
</ul>

  <p>Any one or more of three mechanisms can be used to specify the
    Fortran source file(s) to be wrapped:</p>
  
  <ol>
    <li>Name the files on the command line using full or relative paths</li>
    <li>The <tt>-g</tt> option will wrap all <tt>.f90</tt>
      and <tt>.F90</tt> source files found in the current working
      directory.</li>
    <li>Use the <tt>--file-list</tt> option to name a file that
      contains a list of source files to be wrapped.  The format of this
      file is a newline-separated list of files to be wrapped.</li>
  </ol>


  <h2><a name="ConfigFile">The Configuration File</a></h2>

  <p>The <tt>-i</tt> option can be used to specify a file to read
    simple configuration directives from.  This is not required, but can
    provide more control over the generated wrapper interface, and may
    be useful when wrapping very large projects.</p>

  <p>The format of the configuration file is a simple list of
    directives separated by newlines.  The directives start with
    the <tt>%</tt> character: any line that doesn't match a directive
    is treated as a comment and ignored, so comments may be
    interspersed freely without any special prefix.  Also any
    character can be inserted before a valid directive to comment it
    out, as in "<tt>// %ignore foo</tt>"</p>

  <p>The following directives are supported:</p>

  <ul>
    <li><tt>%ignore &lt;name&gt;</tt></li>
    <li><tt>%hide &lt;procedure&gt; &lt;argument&gt;</tt></li>
    <li><tt>%include &lt;name&gt;</tt></li>
    <li><tt>%rename &lt;old&gt; &lt;new&gt;</tt></li>
  </ul>

  <h3>Ignore directive</h3>

  <p>The ignore directive is used to prevent FortWrap from creating
    wrapper code for certain constructs.  This may be useful when
    creating a C++ API for a large Fortran project, particularly when
    some Fortran declarations must be kept public even though they are
    really not part of the API (keep in mind that FortWrap will
    resepct <tt>PUBLIC</tt> and <tt>PRIVATE</tt> declarations, so
    there is no need to use the ignore directive for <tt>PRIVATE</tt>
    names.)</p>

  <p><tt>&lt;name&gt;</tt> may be the identifier for either a derived
    type or a procedure.  If a derived type is ignored, the
    corresponding proxy class is not crated.  If a procedure is
    ignored, it is not included in the generated wrapper code.</p>

  <h3>Hide directive</h3>

  <p>The hide directive allows specific procedure arguments to be
    hidden from the generated interface.  This is only valid if the
    specified argument of the specified procedure is optional.  All
    calls from the C++ interface treat the argument as not present.
    This directive can be useful for simplifying the generated C++
    API.</p>

  <h3>Include directive</h3>

  <p>The include directive can be used to force-include a wrapper for
    either a derived type or a procedure that is <tt>PRIVATE</tt> in the
    Fortran module.</p>

  <h3>Rename directive</h3>

  <p>The rename directive can operate on either a derived type or a
    procedure.  The name <tt>&lt;old&gt;</tt> found in the Fortran
    source is replaced by the name <tt>&lt;new&gt;</tt> in the
    generated wrapper code.</p>


<h2><a name="Swig">Swig tips (or how to use with other languages)</a></h2>

  <p>One of the principal advantages of wrapping code with FortWrap is
    that the generated wrappers work well as input for Swig.  This
    makes FortWrap useful even if you don't want to work with C++.
    Just tell Swig to wrap the FortWrap-generated header files for the
    target language of your choice.</p>

  <p>Here are some tips:</p>

  <ul>
    <li>Make sure to use the <tt>-c++</tt> option with Swig</li>

    <li>If your target language supports it, use <tt>-keyword</tt>
      (Python supports this).  This way, even though your optional
      arguments must be passed by location in C++, they can be passed by
      keyword in the target language.</li>

    <li>Use <tt>%apply int *INPUT { const int* };</tt> to create an
      input typemap (repeat for <tt>double*</tt>).  This will only
      catch scalars because FortWrap uses classes
      (<tt>std::vector</tt> and <tt>FortranMatrix</tt>) for arrays (or
      "<tt>[]</tt>" in the case of <tt>--c-arrays</tt>).  This is
      compatible with the way optional arguments are treated.</li>

    <li>Use <tt>%apply int *OUTPUT { int* };</tt> to create an
      output typemap.  Note, however, that <tt>INTENT(OUT)</tt>
      and <tt>INTENT(INOUT)</tt> arguments are not distinguishable
      based on the C header file, so this typemap will not work when
      the input value really is used.  This is why FortWrap writes
      warnings for arguments that are not explicitly declared
      either <tt>INTENT(IN)</tt> or <tt>INTENT(OUT)</tt>.  Caution is
      also needed if using this typemap in conjunction with optional
      arguments: because of the way the typemap works, there will be
      no way to "not pass" the optional argument from the target
      language.  This limitation can be worked around by creating a
      custom typemap.</li>

    <li>Be careful with using
      Swig's <a href="http://www.swig.org/Doc1.3/Library.html#Library_nn15"><tt>std_vector.i</tt></a>
      library.  This drastically increases the size of the wrapper
      code and is not compatible with keyword arguments.  I am also
      not aware of a way to use this library
      with <tt>vector&lt;&gt;*</tt> arguments that are meant to store
      outputs (which typically play a big role in the wrapper code
      that FortWrap generates, since input arguments are qualified
      by <tt>const</tt>).  You are probably better off writing your
      own typemaps to handle the <tt>const</tt> and
      non-<tt>const</tt> <tt>vector</tt> arguments.  If you would
      rather have Swig handle C-style arrays, use FortWrap
      with <tt>--c-arrays</tt></li>

    <li>To wrap string outputs, you may <tt>%include
	"<a href="http://www.swig.org/Doc1.3/Library.html#Library_nn14">std_string.i</a>"</tt>,
	but you will need to write an <tt>argout</tt> typemap to
      handle the string pointer as an output.</li>

    <li>There are a couple different ways to work with function
      pointers in the target language (in Python, at least).  See
      the <a href="http://www.swig.org/Doc1.3/SWIG.html#SWIG_nn30">Swig
      documentation</a>.  The simplest is to use Swig directives to
      wrap an existing C/C++ function as a <tt>%constant</tt> that can
      be passed as an argument in the target language.  With Python,
      it is also possible to define the callback function in the
      target language; this is
      explained <a href="http://docs.python.org/release/2.5.2/ext/callingPython.html">here</a>
      in the Python documentation.</li>
  </ul>
  

  <h2><a name="Details">Wrapper Details</a></h2>

  <ul>
    <li><a href="#details-dt">Derived Types</a></li>
    <li><a href="#details-opt">Optional Arguments</a></li>
    <li><a href="#details-orphans">Non-method procedures</a></li>
    <li><a href="#details-arrays">Arrays</a></li>
    <li><a href="#details-matrices">Matrices</a></li>
    <li><a href="#details-procpointers">Procedure Pointers</a></li>
    <li><a href="#details-strings">Strings</a></li>
    <li><a href="#details-global">Top-level procedures</a></li>
    <li><a href="#details-comments">Doxygen comments</a></li>
  </ul>

  <h3><a name="details-dt">Derived Types</a></h3>

  <p>The main goal of FortWrap is to allow users to develop C++
    interfaces to Fortran code that applies object oriented techniques
    by making use of derived types.  In order to interface with
    Fortran derived types, FortWrap uses an object handle approach,
    where a pointer to the derived type is stored and passed to
    arguments that operate on that derived type.  Thus the derived
    type can not be directly inspected from C++, but the object handle
    (pointer) can be passed to Fortran routines that operate on
    it.</p>

  <p>FortWrap scans the Fortran source code for definitions of derived
    types and Fortran subroutines that operate on those derived types.
    For each derived type it finds, it creates a corresponding C++
    class.  After parsing the Fortran source code, C++ methods are
    then created by associating Fortran subroutines with derived
    types.  The rule for this association process is
    simple: <span class="hl">each Fortran subroutine with a derived
    type as its first argument is translated into a method of the
    corresponding C++ class.</span></p>

  <p>FortWrap also provides special mechanisms for wrapping certain
    Fortran routines as C++ constructors and destructors.  If a
    Fortran routine can be classified as a method and contains the
    string "<tt>_ctor</tt>", it is translated into a C++ constructor
    for the corresponding class.  Multiple constructors are supported,
    provided the resulting C++ code will compile (i.e. the function
    signatures are different).  Similarly, if a Fortran routine
    contains the string "<tt>_dtor</tt>", it is treated as a
    destructor and automatically called from the C++ destructor.
    These types of methods are useful for derived types that make use
    of dynamically allocated memory.</p>
    

  <h3><a name="details-opt">Optional Arguments</a></h3>

  <p>Fortran 90 provides for optional procedure arguments that may be
    passed by position or keyword from Fortran.  Although
    interoperating with optional arguments is not explicitly provided
    for by the Fortran standard, FortWrap takes advantage of the fact
    that both the g95 and gfortran compilers implement optional
    arguments in a simple manner that is easy to mimic from C code.
    Specifically, these compilers use null pointers to indicate
    optional arguments that are not present.</p>

  <p>FortWrap exploits this by allowing the arguments to be optional
    from C++.  The usage is not quite as friendly as it would be from
    Fortran, though, since C++ does not support keyword arguments.
    However, FortWrap tries to make the usage as simple as possible by
    automatically giving all optional arguments default values
    of <tt>NULL</tt>.  Note also that one consequence of using
    optional arguments is that they may not be passed by value from
    C++.  Normally FortWrap will wrap primitive scalar types
    with <tt>INTENT(IN)</tt> as pass-by-value arguments from C++, but
    FortWrap must resort to pass-by-reference for optional arguments
    (however, see the<a href="#Swig">Swig notes</a>; if re-wrapping
    with Swig, this is not an issue).</p>

  <p>Consider the following Fortran subroutine:</p>

<div class="code"><pre>
SUBROUTINE foo(o,a,b,c,d)
  TYPE(Object) :: o
  INTEGER, INTENT(IN) :: a
  INTEGER, INTENT(IN), OPTIONAL :: b, c
  INTEGER, INTENT(OUT), OPTIONAL :: d
  ...
END SUBROUTINE foo
</pre></div>  

  <p>Given that an instance <tt>o</tt> as well
    as <tt>int</tt>'s <tt>a</tt>, <tt>b</tt>, <tt>c</tt>,
    and <tt>d</tt> have been declared, the following are examples of
    valid C++ calls:</p>

<div class="targetlang"><pre>
o.foo(a);
o.foo(a,&b);
o.foo(a,NULL,&c);
o.foo(a,&b,&c,&d);
o.foo(a,NULL,NULL,&d);
</pre></div>

  <p>Note that <tt>a</tt> is passed by value, whereas the optional
    arguments must be passed by reference.  Also note that it makes
    sense to define the most used optional arguments at the start of the
    argument list, because the optional arguments must be passed by
    position, and intermediate optional arguments not being provided
    must be passed <tt>NULL</tt>.</p>
    
  <h3><a name="details-orphans">Non-method procedures</a></h3>

  <p>FortWrap can wrap procedures that do not operate on a derived
    type.  In keeping with the object-oriented slant (and also to
    reduce namespace pollution), such procedures are by default
    wrapped as static methods of a dummy class
    named <tt>FortFuncs</tt>.  The name of this class can be changed
    using the <tt>--dummy-class</tt> option.</p>

  <p>As an alternative, the <tt>--global</tt> option can be used to
    wrap non-method procedures as global functions defined in
    the <tt>FortFuncs.h</tt> header file.</p>
    

  <h3><a name="details-arrays">Arrays</a></h3>

  <p>By default, arrays are wrapped to <tt>std::vector&lt;&gt;*</tt>,
    with a <tt>const</tt> qualifier for <tt>INTENT(IN)</tt> arguments.
    FortWrap will detect arguments that are used to define the Fortran
    array size; these are hidden from the generated interface and are
    calculated automatically based on the size of the vector container
    that is passed in.</p>
  
  <p>The option <tt>--c-arrays</tt> can be used to create C-style
    arrays, although with this option FortWrap can not hide the array
    size arguments from the generated interface.</p>

  <p>FortWrap does not currently support assumed size
    (e.g. <tt>X(*)</tt>) or assumed shape (e.g. <tt>X(:)</tt>) array
    arguments.  However, both of these cases can be handled by
    creating a Fortran wrapper that FortWrap can wrap.  For
    example, in order to handle a subroutine like:</p>

<div class="code"><pre>
SUBROUTINE bad_sub(x)
  INTEGER :: x(:)
  ...
END SUBROUTINE bad_sub
</pre></div>

  <p>write a Fortran wrapper that calls the original routine:</p>

<div class="code"><pre>
SUBROUTINE bad_sub_wrap(n,x)
  INTEGER, INTENT(IN) :: n
  INTEGER :: x(n)
  CALL bad_sub(x)
END SUBROUTINE bad_sub_wrap
</pre></div>

  <p>There is the possibility of a future version of FortWrap creating
    these types of wrappers automatically.</p>

  <h3><a name="details-matrices">Matrices</a></h3>

  <p>Matrices are wrapped using a special template
    class <tt>FortranMatrix</tt>.  The header
    file <tt>FortranMatrix.h</tt> is created when needed.  Part of its
    purpose is to hide the fact that C and Fortran store
    multi-dimensional array data in different orders.  Element access
    is provided via the overloaded parentheses operator.  Note that
    although the base Fortran index is 1 (by default), the base index
    used by the <tt>FortranMatrix</tt> class is 0.  Bounds checking is
    done via a C assertion, but this can be tweaked or commented-out
    as needed.</p>

  <p>As an example usage, consider declaring an integer matrix with 4
  rows and 2 columns, and setting the value of the 1st row and 2nd
  column:</p>

<div class="targetlang"><pre>
FortranMatrix&lt;int&gt; X(4,2);
X(0,1) = 10;
</pre></div>


  <h3><a name="details-procpointers">Procedure Pointers</a></h3>

  <p>The Fortran 2003 standard provides support for procedure pointers
    as well as mechanisms for interoperating with procedure pointers
    from C.  Procedure pointer arguments are wrapped by FortWrap with
    the limitation that the interface must be explicit and defined via
    an <tt>ABSTRACT INTERFACE</tt> block.
    See <tt>tests/function_pointers</tt> for example usage.</p>

  <p>FortWrap will parse the abstract interface definition to generate
    the corresponding C function pointer prototype.  Make sure that the
    callback target conforms to this prototype.</p>


  <h3><a name="details-strings">Strings</a></h3>

  <p>Currently only limited support for processing strings is provided.
    In fact, this is a difficult language feature to handle well, and the
    Fortran standard for interoperating with strings is no help.</p>

  <p>FortWrap can only wrap scalar string arguments that
    are <tt>INTENT(OUT)</tt> and have an explicitly declared length
    with <tt>len=</tt>.  Integer literals or named integer parameters
    can be used, provided that the declaration of the parameter name
    is somewhere in a file that FortWrap parsed.</p>

  <h3><a name="details-global">Top-level (non-module) procedures</a></h3>

  <p>FortWrap does not currently wrap so-called "top-level" or
    "global" procedures (i.e. procedures that are not contained within
    a module).  Note that FortWrap is geared towards wrapping modern
    Fortran code, not legacy code.</p>

  <h3><a name="details-comments">Doxygen Comments</a></h3>

  <p>FortWrap automatically transfers Fortran doxygen comments into
    C++ doxygen comments in the generated header files.  This way the
    C++ header files can be processed by doxygen to generate C++ API
    documentation.</p>

  <p>Comments that are transferred may be attached to derived types,
    procedures, and arguments.  FortWrap also adds intent in/out
    specifiers and ARRAY flags to the C++ doxygen comments for
    arguments.  The example in <tt>tests/comments</tt> is provided to
    illustrate the format for using doxygen comments in the Fortran
    source code.</p>


  <h2><a name="Files">Generated Files</a></h2>

<h3><pre>FortWrap.h</pre></h3>

<p>This is a catch-all include file for all of the C++ wrapper code.
Your C++ program only needs to include this.</p>

<h3><pre>CppWrappers.f90</pre></h3>

<p>This source file is generated when either derived types or
  procedure pointers are wrapped.  For each derived type that is being
  wrapped, corresponding "allocate" and "deallocate" wrapper functions
  are generated for creating C "handles" to the Fortran derived type.
  When applicable, this source file will also define a small
  procedure pointer conversion routine.</p>

<h3>Class Wrappers</h3>

<p>For each Fortran derived type being wrapped, a corresponding C++
  class is created.  Two C++ files are created: a header file defining
  the class and a source code file defining the methods.  The header
  file is the place to look to find out how to call the methods that
  FortWrap has generated.</p>

<h3>Dummy Class or Global Wrappers</h3>

  <p>When you wrap procedures that do not operate on a derived type,
    FortWrap wraps them as static members of a dummy C++ class
    called <tt>FortFuncs</tt>.  FortWrap will generate two files to
    define this class: <tt>FortFuncs.h</tt>
    and <tt>FortFuncs.cpp</tt>.  Note that the name of this class and
    its associated files can be changed with
    the <tt>--dummy-class</tt> option.</p>

  <p>When using the <tt>--global</tt> option, the same files are
    created, but the non-method procedures are wrapped as global
    functions.  The <tt>--dummy-class</tt> option also functions to
    change the associated filenames in this case.</p>

<h3><pre>FortranMatrix.h</pre></h3>

<p> This is the definition of the <tt>FortranMatrix</tt> template
  class that is provided for working with matrix arguments.  This file
  is only generated when matrix arguments are wrapped.</p>

<h3><pre>InterfaceDefs.h</pre></h3>

<p>A small header file for FortWrap to declare a few things.</p>


<h2><a name="Support">Support</a></h2>

  <p>FortWrap is actively maintained.  Please don't hesitate to
    contact me if you have any questions, suggestions, complaints,
    feature requests...</p>

  <p>Email John
  at <a href="mailto:mcfarljm@gmail.com">mcfarljm@gmail.com</a></p>

  <p>Get the latest version
    at <a href="https://sourceforge.net/projects/fortwrap/">https://sourceforge.net/projects/fortwrap/</a>.</p>

  <p>Known issues are listed on
    the <a href="http://fortwrap.sourceforge.net/#Issues">project
      website</a></p>
    

</body>

</html>
