<html>
  <head>
    <title>FortWrap Manual</title>
    <link rel=stylesheet href="style.css" type="text/css">
  </head>
    
<body>
  <h1>FortWrap Manual</h1>

  <p>FortWrap is a script that parses Fortran 90/95/200X source files
  and generates wrapper code for interfacing with the original Fortran
  code from C++.  FortWrap is intended to be used with Fortran code
  that takes an object oriented approach and makes use of Fortran
  derived types.  The resulting wrapper code provides a C++ interface
  that masks the Fortran derived types with C++ classes.</p>

  <p>For example, consider the following Fortran code:</p>

  <div class="code"> <pre>
MODULE m

  TYPE Object
    ... 
  END TYPE Object

CONTAINS
    
  SUBROUTINE object_ctor(o, n, x)
    TYPE (Object) :: o
    INTEGER, INTENT(in) :: n
    REAL, INTENT(in) :: x(n)
    ...
  END SUBROUTINE object_ctor

  SUBROUTINE process(o)
    TYPE (Object) :: o
    ...
  END SUBROUTINE process
  
END MODULE m
  </pre></div>      

  <p>After wrapping with FortWrap, these routines can be utilized in a
  natural way from C++:</p>

  <div class="targetlang"> <pre>
std::vector&lt;float&gt; x(10);
... // Define values for x
Object o(&x); // Automatically calls object_ctor
o.process();
  </pre></div>

<h2>Primary Features</h2>

<ul>
  <li> <b>Derived Types</b>: Transparent translation of Fortran derived types into C++ classes.  This is the main objective of FortWrap.</li>
  <ul>
    <li> Translation of Fortran "ctor" functions into C++ constructors</li>
    <li> Fortran "dtor" functions automatically called by C++ destructor</li>
  </ul>

  <li> <b>Optional arguments</b>: Fortran optional arguments are fully
    supported, with automatic NULL default values in C++.</li>

  <li> <b>Procedure pointers</b>: C++ function pointers may be passed
    natively where Fortran expects a procedure pointer.  Right now this
    requires that the Fortran procedure pointer have an
    explict <tt>ABSTRACT INTERFACE</tt></li>
  
  <li> <b>Arrays</b>: One-dimensional arrays are translated into C++
    vector containers.  Subroutine arguments used to define the Fortran
    array size are automatically calculated baesd on the C++ vector.</li>
  
  <li> <b>Matrices</b>: A "FortranMatrix" C++ class is provided for
    interfacing with two-dimensional Fortran arrays (matrices).  This
    class takes care to store data internally in Fortran order.</li>

  <li> Name mangling support for both gfortran and g95 compilers
    
  <li> Character arrays with <tt>INTENT(OUT)</tt> and explicit length
    parameter are translated into C++ strings.</li>

  <li> Where possible, pass by value is used in C++ (e.g. scalar
    arguments that are not optional)</li>

  <li> <b>Doxygen comments</b>: Doxygen-style comments used for
    Fortran symbols (derived types, subroutines, arguments) are
    transferred to C++ doxygen comments in the wrapper code.</li>

  <li> Automatic handling of Fortran <tt>PUBLIC</tt>
    and <tt>PRIVATE</tt> statements.  By default, only <tt>PUBLIC</tt>
    routines are wrapped.</li>
</ul>

<h2>Unsupported Features</h2>

<p>Many features of Fortran 90/95/2003 are not supported by FortWrap.  In
some cases (e.g. assumed shape arrays) this is because the Fortran
language standard does not provide an interoperability mechansim.  In
other cases, this is because there was not a need for certain featuers
  when the original version of FortWrap was being developed.</p>

<p>Note that in most cases FortWrap will quietly leave out wrapper code
for subroutines that contain unsupported argument types that are not
optional.  In most situations, it is possible to get FortWrap to wrap
these types of routines by providing a Fortran wrapper that is
  interoperable and calls the target routine.</p>

<p>The following data types are not permitted as arguments:</p>

<ul>
  <li> Assumed shape arrays (a declaration that looks like <tt>INTEGER
      :: X(:)</tt>).  The Fortran standard does not provide an
      interoperability mechansim for assumed shape arrays.</li>

  <li> Assumed size arrays (<tt>INTEGER :: X(*)</tt>).  These could be
    supported but are less useful than providing an explicit size
    because the Fortran routine will not know the size of the
    array.</li>

  <li> Character arrays with intent other than <tt>INTENT(OUT)</tt></li>

  <li> Arrays of dimensionality greater than 2 are not supported.</li>

  <li> <tt>KIND</tt>: only limited support is provided for specifying
    the <tt>KIND</tt> of primitive types.  For <tt>REAL</tt>
    arguments, <tt>KIND</tt>s of 4 and 8 are supported,
    otherwise <tt>KIND</tt> is not supported.</li>

  <li> Arrays of a derived type.  These can be wrapped by creating a
    new derived type to contain an array of the derived type of
    interest.</li>

  <li> Fortran functions with non-primitive return types are not
    wrapped.</li>

  <li> <b>CLASS</b> (polymorphic) variables.  This Fortran language
    features is not supported by g95 and is currently making its way
    online with gfortran.  Unfortunately, the Fortran 2003 standard
    does not allow C_LOC to be used on <tt>CLASS</tt> pointers, so
    there is not a standard-compliant way of working with these
    variables.  However, experimental support for FortWrap to generate
    polymorphic C++ wrappers around Fortran <tt>CLASS</tt> constructs
    is already underway, although it relies on gfortran-specific
    compiler implementation details and a patched version of the
    compiler.</li>
</ul>

<h2>Getting Started</h2>

<h2>Generated Files</h2>

<h3><pre>FortWrap.h</pre></h3>

<p>This is a catch-all include file for all of the C++ wrapper code.
Your C++ program only needs to include this.</p>

<h3><pre>CppWrappers.f90</pre></h3>

<p>This source file is generated when either derived types or
  procedure pointers are wrapped.  For each derived type that is being
  wrapped, corresponding "allocate" and "deallocate" wrapper functions
  are generated for craeting C "handles" to the Fortran derived type.
  Where applicable, this source file will also define a small
  procedure pointer conversion routine.</p>

<h3>Class Wrappers</h3>

<p>For each Fortran derived type being wrapped, a corresponding C++
  class is crated.  Two C++ files are created: a header file defining
  the class and a source code file defining the methods.  The header
  file is the place to look to find out how to call the methods that
  FortWrap has generated.</p>

<h3>Global Wrappers</h3>

<p>When you wrap global subroutines (i.e. ones that aren't inside a
  Fortran module), FortWrap wraps them as static members of a dummy
  C++ class called <tt>FortFuncs</tt>.  FortWrap will generate two
  files to define this class: <tt>FortFuncs.h</tt>
  and <tt>FortFuncs.cpp</tt>.</p>

<h3><pre>FortranMatrix.h</pre></h3>

<p> This is the definition of the <tt>FortranMatrix</tt> template
  class that is provided for working with matrix arguments.  This file
  is only generated when matrix arguments are wrapped.</p>

<h3><pre>InterfaceDefs.h</pre></h3>

<p>A small header file for FortWrap to declare a few things.</p>


<h2>Details</h2>

<h3>Derived Types</h3>

  <p>The main goal of FortWrap is to allow users to develop C++
    interfaces to Fortran code that applies object oriented techniques
    by making use of derived types.  In order to interface with
    Fortran derived types, FortWrap uses an object handle approach,
    where a pointer to the derived type is stored and passed to
    arguments that operate on that derived type.  Thus the derived
    type can not be directly inspected from C++, but the object handle
    (pointer) can be passed to Fortran routines that operate on it</p>

  <p>FortWrap scans the Fortran source code for definitions of derived
    types and Fortran subroutines that operate on those derived types.
    For each derived type it finds, it creates a corresponding C++
    class.  After parsing the Fortran source code, C++ methods are
    then created by associating Fortran subroutines with derived
    types.  The rule for this association process is
    simple: <span class="hl">each Fortran subroutine with a derived
    type as its first argument is translated into a method of the
    corresponding C++ class.</span></p>

  <p>FortWrap also provides special mechanisms for wrapping certain
    Fortran routines as C++ constructors and destructors.  If a
    Fortran routine can be classified as a method and contains the
    string "<tt>_ctor</tt>", it is translated into a C++ constructor
    for the corresponding class.  Multiple constructors are supported,
    provided the resulting C++ code will compile (i.e. the function
    signatures are different).  Similarly, if a Fortran routine
    contains the string "<tt>_dtor</tt>", it is treated as a
    destructor and automatically called from the C++ destructor.
    These types of methods are useful for derived types that make use
    of dynamically allocated memory.</p>
    

<h3>Optional Arguments</h3>

  <p>Fortran 90 provides for optional procedure arguments that may be
    passed by position or keyword from Fortran.  Although
    interoperating with optional arguments is not explicitly provided
    for by the Fortran standard, FortWrap takes advantage of the fact
    that both the g95 and gfortran compilers implement optional
    arguments in a simple manner that is easy to mimic from C code.
    Specifically, the compiler uses null pointers to indicate optional
    arguments that are not present.</p>

  <p>FortWrap exploits this by allowing the arguments to be optional
    from C++.  The usage is not quite as friendly as it would be from
    Fortran, though, since C++ does not support keyword arguments.
    However, FortWrap tries to make the usage as simple as possible by
    automatically giving all Fortran optional arguments default values
    of <tt>NULL</tt>.  Note also that one consequence of using
    optional arguments is that they may not be passed by value from
    C++.  Normally FortWrap will wrap primitive scalar types
    with <tt>INTENT(IN)</tt> as pass-by-value arguments from C++, but
    FortWrap must resort to pass-by-reference for optional
    arguments.</p>

  <p>Consider the following Fortran subroutine:</p>

<div class="code"><pre>
SUBROUTINE foo(o,a,b,c,d)
  TYPE(Object) :: o
  INTEGER, INTENT(IN) :: a
  INTEGER, INTENT(IN), OPTIONAL :: b, c
  INTEGER, INTENT(OUT), OPTIONAL :: d
  ...
END SUBROUTINE foo
</pre></div>  

  <p>Given that an instance <tt>o</tt> as well
    as <tt>int</tt>'s <tt>a</tt>, <tt>b</tt>, <tt>c</tt>,
    and <tt>d</tt> have been declared, the following are examples of
    valid C++ calls:</p>

<div class="targetlang"><pre>
o.foo(a);
o.foo(a,&b);
o.foo(a,NULL,&c);
o.foo(a,&b,&c,&d);
o.foo(a,NULL,NULL,&d);
</pre></div>

  <p>Note that <tt>a</tt> is passed by value, whereas the optional
  arguments must be passed by reference.  Also note that it makes
  sense to define the most used optional arguments at the start of the
  argument list, because the optional arguments must be passed by
  position, and intermediate optional arguments not being provided
  must be passed <tt>NULL</tt>.


<h3>Procedure Pointers</h3>

  <p>The Fortran 2003 standard provides support for procedure pointers
    as well as mechanisms for interoperating with procedure pointers
    from C.  Procedure pointer arguments are wrapped by FortWrap with
    the limitation that the interface must be explicit and defined via
    an <tt>ABSTRACT INTERFACE</tt> block.
    See <tt>tests/function_pointers</tt> for example usage.</p>

<h3>Arrays</h3>

  <p>FortWrap does not currently support assumed size
    (e.g. <tt>X(*)</tt>) or assumed shape (e.g. <tt>X(:)</tt>) array
    arguments.  However, both of these cases can be handled by
    creating a Fortran wrapper that FortWrap can wrap.  For
    example, in order to handle a subroutine like:</p>

<div class="code"><pre>
SUBROUTINE bad_sub(x)
  INTEGER :: x(:)
  ...
END SUBROUTINE bad_sub
</pre></div>

  <p>write a Fortran wrapper that calls the original routine:</p>

<div class="code"><pre>
SUBROUTINE bad_sub_wrap(n,x)
  INTEGER, INTENT(IN) :: n
  INTEGER :: x(n)
  CALL bad_sub(x)
END SUBROUTINE bad_sub_wrap
</pre></div>

  <p>I am currently working on getting FortWrap to generate these
    types of wrappers automatically...</p>

<h3>Matrices</h3>

<h3>Global (non-module) Procedures</h3>

<h3>Strings</h3>

</body>

</html>
